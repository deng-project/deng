/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <common/base_types.h>
#include <das/assets.h>
#include <das/das_loader.h>
#include <das/wavefront_obj.h>

/*
 * The goal of this test is to do following:
 * 1. Read data from all cube files into file cube_<variant>.test
 * 2. If the file matches file cube_<variant>.expected then test was successful otherwise
 * the test failed.
 */

// Create new asset file
void mkAssetLog(das_Asset *p_asset, deng_bool_t is_test_file) {
    FILE *file;
    char filename[32] = {0};
    char buf[128] = {0};
    if(is_test_file)
        sprintf(filename, "cube_VAR.test");
    else sprintf(filename, "cube_VAR.expected");

    switch(p_asset->asset_mode)
    {
    case DAS_ASSET_MODE_3D_UNMAPPED:
        filename[5] = 'v';
        filename[6] = 'u';
        filename[7] = 'u';
        file = fopen(filename, "wb");

        for(size_t i = 0; i < p_asset->vertices.n; i++) {
            memset(buf, 0, 128);
            sprintf (
                buf,
                "v %f %f %f\n",
                p_asset->vertices.vuu[i].vert_x,
                p_asset->vertices.vuu[i].vert_y,
                p_asset->vertices.vuu[i].vert_z
            );
            fwrite(buf, sizeof(char), strlen(buf), file);
        }
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        filename[5] = 'v';
        filename[6] = 'u';
        filename[7] = 'n';
        file = fopen(filename, "wb");

        for(size_t i = 0; i < p_asset->vertices.n; i++) {
            memset(buf, 0, 128);
            sprintf (
                buf,
                "v %f %f %f | %f %f %f\n",
                p_asset->vertices.vun[i].vert_data.vert_x,
                p_asset->vertices.vun[i].vert_data.vert_y,
                p_asset->vertices.vun[i].vert_data.vert_z,
                p_asset->vertices.vun[i].norm_data.nor_x,
                p_asset->vertices.vun[i].norm_data.nor_y,
                p_asset->vertices.vun[i].norm_data.nor_z
            );
            fwrite(buf, sizeof(char), strlen(buf), file);
        }
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        filename[5] = 'v';
        filename[6] = 'm';
        filename[7] = 'u';
        file = fopen(filename, "wb");


        for(size_t i = 0; i < p_asset->vertices.n; i++) {
            memset(buf, 0, 128);
            sprintf (
                buf,
                "v %f %f %f | %f %f\n",
                p_asset->vertices.vmu[i].vert_data.vert_x,
                p_asset->vertices.vmu[i].vert_data.vert_y,
                p_asset->vertices.vmu[i].vert_data.vert_z,
                p_asset->vertices.vmu[i].tex_data.tex_x,
                p_asset->vertices.vmu[i].tex_data.tex_y
            );
            fwrite(buf, sizeof(char), strlen(buf), file);
        }
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        filename[5] = 'v';
        filename[6] = 'm';
        filename[7] = 'n';
        file = fopen(filename, "wb");

        for(size_t i = 0; i < p_asset->vertices.n; i++) {
            memset(buf, 0, 128);
            sprintf (
                buf,
                "v %f %f %f | %f %f | %f %f %f\n",
                p_asset->vertices.vmn[i].vert_data.vert_x,
                p_asset->vertices.vmn[i].vert_data.vert_y,
                p_asset->vertices.vmn[i].vert_data.vert_z,
                p_asset->vertices.vmn[i].tex_data.tex_x,
                p_asset->vertices.vmn[i].tex_data.tex_y,
                p_asset->vertices.vmn[i].norm_data.nor_x,
                p_asset->vertices.vmn[i].norm_data.nor_y,
                p_asset->vertices.vmn[i].norm_data.nor_z
            );
            fwrite(buf, sizeof(char), strlen(buf), file);
        }
        break;

    default:
        return;
    }

    for(size_t i = 0; i < p_asset->indices.n; i++) {
        memset(buf, 0, 128);
        sprintf (
            buf,
            "%d ",
            p_asset->indices.indices[i]
        );

        fwrite(buf, sizeof(char), strlen(buf), file);
    }
    fclose(file);
}


void clearassets(das_Asset *vuu, das_Asset *vun, das_Asset *vmu, das_Asset *vmn) {
    // Free all data that has been allocated for assets during wavefront obj parsing
    free(vuu->vertices.vuu);
    free(vun->vertices.vun);
    free(vmu->vertices.vmu);
    free(vmn->vertices.vmn);

    free(vuu->indices.indices);
    free(vun->indices.indices);
    free(vmu->indices.indices);
    free(vmn->indices.indices);

    vuu->indices.n = 0;
    vun->indices.n = 0;
    vmu->indices.n = 0;
    vmn->indices.n = 0;

    vuu->vertices.n = 0;
    vun->vertices.n = 0;
    vmu->vertices.n = 0;
    vmn->vertices.n = 0;
}


/* 
 * Compare file contents between expected and tested files and check if they match
 */
deng_bool_t cmpfiles(char *exp_file, char *test_file) {
    char *exp;
    char *test;

    size_t exp_size;
    size_t test_size;

    FILE *fexp = fopen(exp_file, "rb");
    FILE *ftest = fopen(test_file, "rb");
    if(!fexp) {
        printf("No file %s\n", exp_file);
        return false;
    }

    if(!ftest) {
        printf("No file %s\n", test_file);
        return false;
    }

    fseek(fexp, 0, SEEK_END);
    exp_size = ftell(fexp);
    fseek(fexp, 0, SEEK_SET);

    fseek(ftest, 0, SEEK_END);
    test_size = ftell(ftest);
    fseek(ftest, 0, SEEK_SET);

    if(exp_size != test_size) {
        printf("Log file sizes do not match\n");
        return false;
    }

    exp = calloc(exp_size + 1, sizeof(char));
    test = calloc(test_size + 1, sizeof(char));

    fread(exp, sizeof(char), exp_size, fexp);
    fread(test, sizeof(char), test_size, ftest);

    if(strcmp(exp, test))
        return false;

    fclose(ftest);
    fclose(fexp);

    return true;
}


int main() {
    das_Asset vuu, vun, vmu, vmn;
    das_ParseWavefrontOBJ(&vuu, DAS_ASSET_MODE_3D_UNMAPPED, "../objects/cube.obj");
    das_ParseWavefrontOBJ(&vun, DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED, "../objects/cube.obj");
    das_ParseWavefrontOBJ(&vmu, DAS_ASSET_MODE_3D_TEXTURE_MAPPED, "../objects/cube.obj");
    das_ParseWavefrontOBJ(&vmn, DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED, "../objects/cube.obj");
    
    // Write asset data into file
    mkAssetLog(&vuu, true);
    mkAssetLog(&vun, true);
    mkAssetLog(&vmu, true);
    mkAssetLog(&vmn, true);

    clearassets(&vuu, &vun, &vmu, &vmn);

    // Load data from asset files into asset structures
    das_ReadAsset(&vuu, DAS_ASSET_MODE_DONT_CARE, "../assets/test_cubes/cube_vuu.das");
    das_ReadAsset(&vun, DAS_ASSET_MODE_DONT_CARE, "../assets/test_cubes/cube_vun.das");
    das_ReadAsset(&vmu, DAS_ASSET_MODE_DONT_CARE, "../assets/test_cubes/cube_vmu.das");
    das_ReadAsset(&vmn, DAS_ASSET_MODE_DONT_CARE, "../assets/test_cubes/cube_vmn.das");

    // Write asset data into expected file
    mkAssetLog(&vuu, false);
    mkAssetLog(&vun, false);
    mkAssetLog(&vmu, false);
    mkAssetLog(&vmn, false);

    deng_bool_t vuu_test = cmpfiles("cube_vuu.expected", "cube_vuu.test");
    deng_bool_t vun_test = cmpfiles("cube_vun.expected", "cube_vun.test");
    deng_bool_t vmu_test = cmpfiles("cube_vmu.expected", "cube_vmu.test");
    deng_bool_t vmn_test = cmpfiles("cube_vmn.expected", "cube_vmn.test");

    if(vuu_test && vun_test && vmu_test && vmn_test)
        printf("Test successful!\n");
    else printf("Test failed!\n");

    clearassets(&vuu, &vun, &vmu, &vmn);
    return EXIT_SUCCESS;
}
