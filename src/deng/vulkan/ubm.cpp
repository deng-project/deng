/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __UBM_CPP
#include <deng/vulkan/ubm.h>


namespace deng {
    namespace vulkan {

        // This is a fucking war crime
        extern deng_ui32_t __max_frame_c;


        __vk_UniformBufferManager::__vk_UniformBufferManager (
            std::vector<deng_Id> &assets,
            const deng_ui64_t min_align, 
            deng::__GlobalRegistry &reg,
            __vk_BufferData &buf_data
        ) : m_assets(assets), m_min_align(min_align), m_reg(reg),
            m_buffer_data(buf_data) {}


        /// Create new uniform buffer instance and allocate memory for it.
        /// WARNING: This method call expects that uniform buffer and its memory
        /// have been freed or are not initialised previously
        void __vk_UniformBufferManager::__mkUniformBuffer (
            VkDevice device, 
            VkPhysicalDevice gpu,
            VkCommandPool cmd_pool, 
            VkQueue g_queue,
            deng_ui64_t asset_cap
        ) {
            m_buffer_data.ubo_asset_cap = asset_cap;

            // Calculate the chunk size for uniform data
            m_ubo_chunk_size = cm_FindChunkSize(m_min_align,
                sizeof(__vk_UniformObjectTransform)) + cm_FindChunkSize(
                m_min_align, sizeof(__vk_UniformObjectTransform2D)) +
                cm_FindChunkSize(m_min_align, sizeof(__vk_UniformLightData));

            LOG("__vk_UniformObjectTransform size: " + std::to_string(cm_FindChunkSize(m_min_align, 
                sizeof(__vk_UniformObjectTransform))) + ", real: " + std::to_string(sizeof(__vk_UniformObjectTransform)));

            LOG("__vk_UniformObjectTransform2D size: " + std::to_string(cm_FindChunkSize(m_min_align, 
                sizeof(__vk_UniformObjectTransform2D))) + ", real: " + std::to_string(sizeof(__vk_UniformObjectTransform2D)));

            LOG("__vk_UniformLightData size: " + std::to_string(cm_FindChunkSize(m_min_align, 
                sizeof(__vk_UniformLightData))) + ", real: " + std::to_string(sizeof(__vk_UniformLightData)));

            LOG("Ubo chunk size, min_align: " + std::to_string(m_ubo_chunk_size) + ", " + std::to_string(m_min_align));
            
            // Calculate the initial uniform buffer capacity 
            // Data is stored like this: fc * (Transform + Transform2D + LightData) + n * ColorData
            m_buffer_data.ubo_cap = __max_frame_c * (m_ubo_chunk_size + asset_cap * 
                cm_FindChunkSize(m_min_align, sizeof(__vk_UniformColorData)));
            
            // Create a new uniform buffer instance
            VkMemoryRequirements mem_req = __vk_BufferCreator::makeBuffer(device, gpu, 
                m_buffer_data.ubo_cap, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                m_buffer_data.uniform_buffer);

            // Allocate memory for uniform buffer
            __vk_BufferCreator::allocateMemory(device, gpu, mem_req.size,
                m_buffer_data.uniform_buffer_mem, mem_req.memoryTypeBits,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

            // Bind the newly created buffer with newly allocated buffer memory
            vkBindBufferMemory(device, m_buffer_data.uniform_buffer, m_buffer_data.uniform_buffer_mem, 0);
        }


        /// Reallocate memory for uniform buffer and copy previous data to
        /// newly allocated buffer instance
        void __vk_UniformBufferManager::__reallocUniformBufferMemory (
            VkDevice device,
            VkPhysicalDevice gpu,
            VkCommandPool cmd_pool,
            VkQueue g_queue,
            deng_ui64_t req_cap
        ) {
            // Create a new staging buffer for the previous uniform data
            VkMemoryRequirements mem_req = __vk_BufferCreator::makeBuffer(device, gpu,
                m_buffer_data.ubo_cap, VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                m_buffer_data.staging_buffer);
            
            // Allocate memory for the staging buffer
            __vk_BufferCreator::allocateMemory(device, gpu,
                mem_req.size, m_buffer_data.staging_buffer_memory, 
                mem_req.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | 
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);

            // Bind the staging buffer with its memory
            vkBindBufferMemory(device, m_buffer_data.staging_buffer, m_buffer_data.staging_buffer_memory, 0);

            // Copy from uniform buffer to staging buffer
            __vk_BufferCreator::cpyBufferToBuffer(device, cmd_pool, g_queue, m_buffer_data.uniform_buffer, 
                m_buffer_data.staging_buffer, m_buffer_data.ubo_cap, 0, 0);

            // Free all resources used in uniform buffers
            vkDestroyBuffer(device, m_buffer_data.uniform_buffer, NULL);
            vkFreeMemory(device, m_buffer_data.uniform_buffer_mem, NULL);

            // Allocate memory for new uniform buffer instance
            __mkUniformBuffer(device, gpu, cmd_pool, g_queue, req_cap);

            // Copy from staging buffer to the newly created uniform buffer instance
            __vk_BufferCreator::cpyBufferToBuffer(device, cmd_pool, g_queue, m_buffer_data.staging_buffer, 
                m_buffer_data.uniform_buffer, m_buffer_data.ubo_cap, 0, 0);
        }


        /// Reset uniform buffer size to first asset color data instance
        void __vk_UniformBufferManager::__resetUboBufferSize() {
            m_buffer_data.ubo_size = __max_frame_c * m_ubo_chunk_size;
        }


        /// Copy asset color data to uniform buffer memory
        void __vk_UniformBufferManager::cpyAssetUniform (
            VkDevice device,
            VkPhysicalDevice gpu,
            VkCommandPool cmd_pool,
            VkQueue g_queue,
            __vk_Asset &asset
        ) {
            // Retrieve the base asset and set its ubo offset
            RegType &reg_asset = m_reg.retrieve(asset.base_id, DENG_SUPPORTED_REG_TYPE_ASSET);
            reg_asset.asset.offsets.ubo_offset = m_buffer_data.ubo_size;
            LOG("Asset ubo offset: " + std::to_string(reg_asset.asset.offsets.ubo_offset));

            // Set the ubo color according to the color data
            __vk_UniformColorData ubo;
            ubo.color = dengMath::vec4<deng_vec_t>{
                reg_asset.asset.color.col_r,
                reg_asset.asset.color.col_g,
                reg_asset.asset.color.col_b,
                reg_asset.asset.color.col_a
            };
            
            // Check if reg type is unmapped or not and set the flag accordingly
            if(reg_asset.asset.asset_mode == DAS_ASSET_MODE_2D_UNMAPPED ||
               reg_asset.asset.asset_mode == DAS_ASSET_MODE_3D_UNMAPPED ||
               !reg_asset.asset.tex_uuid) ubo.is_unmapped = true;
            else ubo.is_unmapped = reg_asset.asset.force_unmap; 

            // Set the new size for ubo buffer
            size_t old_size = m_buffer_data.ubo_size;
            m_buffer_data.ubo_size += __max_frame_c * cm_FindChunkSize(m_min_align,
                sizeof(__vk_UniformColorData));

            // Check if buffer reallocation is needed 
            if(m_buffer_data.ubo_size > m_buffer_data.ubo_cap) {
                // Capcity is either twice the current capacity or twice the required capacity
                __reallocUniformBufferMemory(device, gpu, cmd_pool, g_queue, 
                    std::max(m_buffer_data.ubo_asset_cap << 1, cm_ToPow2I64(m_buffer_data.ubo_size << 1)));
            }

            
            // For each frame copy the asset uniform to buffer
            for(size_t i = 0; i < __max_frame_c; i++) {
                // Copy all uniform data to buffer
                __vk_BufferCreator::cpyToBufferMem(device, sizeof(__vk_UniformColorData), 
                    (void*) &ubo, m_buffer_data.uniform_buffer_mem, old_size + i * cm_FindChunkSize(
                    m_min_align, sizeof(__vk_UniformColorData)));
            }
        }


        /// Update transfrom uniform data in the frame according to updated camera
        /// and view matrix
        void __vk_UniformBufferManager::updateUboTransform3D(
            VkDevice device, 
            deng_ui32_t current_image, 
            Camera3D *p_cam
        ) {
            __vk_UniformObjectTransform ubo;
            ubo.transform = p_cam->getCameraMat();
            ubo.view = p_cam->getViewMat();

            __vk_BufferCreator::cpyToBufferMem(device, sizeof(__vk_UniformObjectTransform),
                &ubo, m_buffer_data.uniform_buffer_mem, current_image * m_ubo_chunk_size);
        }


        /// Update lighting uniform data
        void __vk_UniformBufferManager::updateUboLighting (
            VkDevice device,
            LightSource light_srcs[__DENG_MAX_LIGHT_SRC_COUNT],
            dengMath::vec4<deng_vec_t> ambient,
            deng_ui32_t current_image
        ) {
            __vk_UniformLightData data = { { 0 } };
            data.ambient = ambient;
            data.light_src_c = 0;
            data.intensity = 5.0f; 
            data.pos = dengMath::vec3<deng_vec_t>{1.0f, 1.0f, 1.0f}; 

            __vk_BufferCreator::cpyToBufferMem(device, sizeof(__vk_UniformLightData),
                &data, m_buffer_data.uniform_buffer_mem, current_image * m_ubo_chunk_size +
                cm_FindChunkSize(m_min_align, sizeof(__vk_UniformObjectTransform)) + 
                cm_FindChunkSize(m_min_align, sizeof(__vk_UniformObjectTransform2D)));

        }

        
        /// Basically set the ambient lighting to 100%
        /// Call this method when no light sources are specified
        void __vk_UniformBufferManager::mkStandardLight(VkDevice device) {
            LightSource light_srcs[__DENG_MAX_LIGHT_SRC_COUNT] = {};

            // For each frame in flight map the light data
            for(deng_ui32_t i = 0; i < __max_frame_c; i++) {
                // Map the light data with 100% ambient color
                updateUboLighting(device, light_srcs, dengMath::vec4<deng_vec_t>{
                 0.3f, 0.3f, 0.3f, 1.0f}, i);
            }
        }


        /// Initialise uniform buffer for storing data
        void __vk_UniformBufferManager::initUniformBuffer (
            VkDevice device, 
            VkPhysicalDevice gpu,
            VkCommandPool cmd_pool, 
            VkQueue g_queue
        ) {
            __mkUniformBuffer(device, gpu, cmd_pool, g_queue, __DEFAULT_ASSET_CAP);
            __resetUboBufferSize();
        }

        
        /// Getter methods
        deng_ui64_t __vk_UniformBufferManager::getUboChunkSize() { return m_ubo_chunk_size; }
    }
}
