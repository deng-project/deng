/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __VULKAN_RENDERER_CPP
#include <deng/vulkan/vulkan_renderer.h>

deng::__SharedMouseData __ext_md;

namespace deng {
    namespace vulkan {
        extern deng_ui32_t __max_frame_c;

        /**************************************************/
        /**************************************************/
        /**************************************************/
        /*********** __vk_RuntimeUpdater Class ************/
        /**************************************************/
        /**************************************************/

        /*
         * This method updates the vertices buffer that is allocated by
         * given assets
         */
        void __vk_RuntimeUpdater::__updateAssetVerts(const dengMath::vec2<deng_ui32_t> &asset_bounds) {
            m_p_rm->remapAssetVerts (
                m_p_ic->getDev(),
                m_p_ic->getGpu(),
                m_p_dc->getComPool(),
                m_p_ic->getQFF().graphics_queue,
                asset_bounds
            );
        }

        
        /*
         * Free and reallocate new commandbuffers 
         */
        void __vk_RuntimeUpdater::__updateCmdBuffers(const dengMath::vec4<deng_vec_t> &background) {
            m_p_dc->recordMainCmdBuffers (
                m_p_scc->getRp(),
                m_p_scc->getExt(),
                background,
                m_p_rm->getBD()
            );
        }

        
        /********************************************/
        /********************************************/
        /********************************************/
        /*********** __vk_Renderer Class ************/
        /********************************************/
        /********************************************/

        __vk_Renderer::__vk_Renderer (
            deng::Window &win,
            const __vk_ConfigVars &cnf,
            deng::__GlobalRegistry &reg
        ) : m_reg(reg), m_win(win) { 
            m_config = cnf;
            __initConstruct();
        }


        __vk_Renderer::~__vk_Renderer() {
            idle();
            __cleanup();
            
            delete m_p_desc_c;
            delete m_p_dc;
            delete m_p_rm;
            delete m_p_scc;
            delete m_p_ic;
        }


        /*
         * Create new renderer creator instances
         */
        void __vk_Renderer::__initConstruct() {
            // Create new VkInstace
            m_p_ic = new __vk_InstanceCreator (
                m_win,
                m_config.enable_validation_layers
            );
            
            // Create new swapchain 
            m_p_scc = new __vk_SwapChainCreator (
                m_p_ic->getDev(),
                m_win,
                m_p_ic->getGpu(), 
                m_p_ic->getSu(), 
                m_p_ic->getQFF(),
                m_config.msaa_sample_count
            );

            // Create new draw caller instance and make command pool
            m_p_dc = new __vk_DrawCaller (
                m_p_ic->getDev(),
                m_p_ic->getQFF(),
                m_assets,
                m_textures,
                m_reg
            );
            
            m_p_dc->mkCommandPool(m_p_ic->getDev());

            __max_frame_c = static_cast<deng_ui32_t>(m_p_scc->getSCImg().size());

            // Create new buffer resources allocator
            m_p_rm = new __vk_ResourceManager (
                m_p_ic->getDev(), 
                m_p_ic->getGpu(),
                m_p_scc->getExt(),
                m_config.msaa_sample_count,
                m_p_scc->getRp(),
                m_p_dc->getComPool(),
                m_p_ic->getQFF().graphics_queue,
                m_p_scc->getSCImgViews(), 
                m_reg, 
                m_assets,
                m_textures,
                m_p_scc->getSF(),
                m_p_ic->getGpuLimits()
            ); 

            // Create new vulkan descriptor creator
            m_p_desc_c = new __vk_DescriptorCreator (
                m_p_ic->getDev(),
                m_p_scc->getExt(),
                m_p_scc->getRp(),
                m_reg,
                m_assets,
                m_textures,
                m_config.msaa_sample_count
            );
        }


        /*
         * Free all depth and color image data
         */
        void __vk_Renderer::__cleanRendImgResources() {
            // Clean depth image resources
            vkDestroyImageView (
                m_p_ic->getDev(), 
                m_p_rm->getDepImgView(), 
                nullptr
            );

            vkDestroyImage (
                m_p_ic->getDev(), 
                m_p_rm->getDepImg(), 
                nullptr
            );

            vkFreeMemory (
                m_p_ic->getDev(), 
                m_p_rm->getDepImgMem(), 
                nullptr
            );

            // Clean color image resources
            vkDestroyImageView (
                m_p_ic->getDev(),
                m_p_rm->getColorImgView(),
                nullptr
            );

            vkDestroyImage (
                m_p_ic->getDev(),
                m_p_rm->getColorImg(),
                nullptr
            );

            vkFreeMemory (
                m_p_ic->getDev(),
                m_p_rm->getColorImgMem(),
                nullptr
            );
        }


        void __vk_Renderer::__cleanDrawCommands() {
            // Clean framebuffers
            std::vector<VkFramebuffer> fb;
            fb = m_p_rm->getFB();
            for(size_t i = 0; i < fb.size(); i++) {
                vkDestroyFramebuffer (
                    m_p_ic->getDev(), 
                    fb[i], 
                    nullptr
                );
            }

            // Clean commandbuffers and commandpools
            vkFreeCommandBuffers (
                m_p_ic->getDev(), 
                m_p_dc->getComPool(), 
                static_cast<deng_ui32_t>(m_p_dc->getComBufs().size()), 
                m_p_dc->getComBufs().data()
            );
        }

        
        void __vk_Renderer::__cleanTextures() {
            for(size_t i = 0; i < m_textures.size(); i++) {
                RegType &reg_vk_tex = m_reg.retrieve (
                    m_textures[i], 
                    DENG_SUPPORTED_REG_TYPE_VK_TEXTURE
                );

                // Check if image has been buffered and if it then has destroy all of its Vulkan related data
                if(reg_vk_tex.vk_tex.is_buffered) {
                    // Destroy texture sampler
                    vkDestroySampler (
                        m_p_ic->getDev(),
                        reg_vk_tex.vk_tex.sampler,
                        NULL
                    );

                    // Destroy texture's image views
                    vkDestroyImageView (
                        m_p_ic->getDev(),
                        reg_vk_tex.vk_tex.image_view,
                        NULL
                    );

                    // Destroy texture image 
                    vkDestroyImage (
                        m_p_ic->getDev(),
                        reg_vk_tex.vk_tex.image,
                        NULL
                    );
                }
            }

            // Free all memory allocated for texture images
            vkFreeMemory (
                m_p_ic->getDev(),
                m_p_rm->getBD()->img_memory,
                NULL
            );
        }

        
        void __vk_Renderer::__cleanAssets() {
            for(size_t i = 0; i < m_assets.size(); i++) {
                RegType &reg_vk_asset = m_reg.retrieve (
                    m_assets[i],
                    DENG_SUPPORTED_REG_TYPE_VK_ASSET
                );

                // Check if asset has descriptor sets allocated and if it does then destroy them
                if(reg_vk_asset.vk_asset.is_desc) {
                    RegType &reg_asset = m_reg.retrieve (
                        reg_vk_asset.vk_asset.base_id,
                        DENG_SUPPORTED_REG_TYPE_ASSET
                    );

                    if (
                        reg_asset.asset.asset_mode == DAS_ASSET_MODE_2D_UNMAPPED ||
                        reg_asset.asset.asset_mode == DAS_ASSET_MODE_3D_UNMAPPED ||
                        reg_asset.asset.asset_mode == DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED ||
                        reg_asset.asset.force_unmap
                    ) {
                        vkFreeDescriptorSets (
                            m_p_ic->getDev(),
                            m_p_desc_c->getUnmappedDP(),
                            static_cast<deng_ui32_t>(reg_vk_asset.vk_asset.desc_c),
                            reg_vk_asset.vk_asset.desc_sets
                        );
                    }

                    else {
                        vkFreeDescriptorSets (
                            m_p_ic->getDev(),
                            m_p_desc_c->getTexMappedDP(),
                            static_cast<deng_ui32_t>(reg_vk_asset.vk_asset.desc_c),
                            reg_vk_asset.vk_asset.desc_sets
                        );
                    }
                }
            }
        }

        
        void __vk_Renderer::__cleanPipelines() {
            // Clean pipeline related data
            std::array<__vk_PipelineData, __DENG_PIPELINE_COUNT> pd = m_p_desc_c->getPipelines();
            for(size_t i = 0; i < pd.size(); i++) { 
                vkDestroyPipeline (
                    m_p_ic->getDev(), 
                    pd[i].pipeline, 
                    nullptr
                );
            }

            // Clean pipeline layout data 
            vkDestroyPipelineLayout (
                m_p_ic->getDev(), 
                m_p_desc_c->getUnmappedPL(), 
                nullptr
            );
            
            vkDestroyPipelineLayout (
                m_p_ic->getDev(), 
                m_p_desc_c->getTexMappedPL(), 
                nullptr
            );

            // Destroy renderpass
            vkDestroyRenderPass (
                m_p_ic->getDev(), 
                m_p_scc->getRp(), 
                nullptr
            );
        }

        
        void __vk_Renderer::__cleanDSL() {
            // Destroy descriptor pools 
            vkDestroyDescriptorPool (
                m_p_ic->getDev(), 
                m_p_desc_c->getUnmappedDP(), 
                nullptr
            );

            vkDestroyDescriptorPool (
                m_p_ic->getDev(), 
                m_p_desc_c->getTexMappedDP(), 
                nullptr
            );

            // Clean descriptor set layouts
            vkDestroyDescriptorSetLayout (
                m_p_ic->getDev(), 
                m_p_desc_c->getUnmappedDSL(), 
                nullptr
            );

            vkDestroyDescriptorSetLayout (
                m_p_ic->getDev(), 
                m_p_desc_c->getTexMappedDSL(), 
                nullptr
            );

        }


        void __vk_Renderer::__freeBuffers() {
            // Clean ubo buffer data 
            vkDestroyBuffer (
                m_p_ic->getDev(), 
                m_p_rm->getBD()->uniform_buffer, 
                nullptr
            );

            vkFreeMemory (
                m_p_ic->getDev(), 
                m_p_rm->getBD()->uniform_buffer_mem, 
                nullptr
            );


            // Clean main buffer data
            vkDestroyBuffer (
                m_p_ic->getDev(), 
                m_p_rm->getBD()->main_buffer, 
                nullptr
            );

            vkFreeMemory (
                m_p_ic->getDev(), 
                m_p_rm->getBD()->main_buffer_memory, 
                nullptr
            );
        }

        
        void __vk_Renderer::__cleanSemaphores() {
            // Clean semaphores and fences
            for(size_t i = 0; i < __max_frame_c; i++) {
                vkDestroySemaphore (
                    m_p_ic->getDev(), 
                    m_p_dc->image_available_semaphore_set[i], 
                    nullptr
                );
                vkDestroySemaphore (
                    m_p_ic->getDev(), 
                    m_p_dc->render_finished_semaphore_set[i], 
                    nullptr
                );
                vkDestroyFence (
                    m_p_ic->getDev(), 
                    m_p_dc->flight_fences[i], 
                    nullptr
                );
            }
        }

        
        void __vk_Renderer::__cleanDevice() {
            vkDestroyCommandPool (
                m_p_ic->getDev(), 
                m_p_dc->getComPool(), 
                nullptr
            );

            // Clean instance and devices
            vkDestroyDevice (
                m_p_ic->getDev(), 
                nullptr
            );

            if(m_config.enable_validation_layers) {
                __vk_InstanceCreator::destroyDebugUtils (
                    m_p_ic->getIns(), 
                    m_p_ic->getDMEXT()
                );
            }

            vkDestroySurfaceKHR (
                m_p_ic->getIns(), 
                m_p_ic->getSu(), 
                nullptr
            );

            
            vkDestroyInstance (
                m_p_ic->getIns(), 
                nullptr
            );
        }


        /*
         * Free and destroy all active vulkan instances
         */
        void __vk_Renderer::__cleanup() {
            __cleanRendImgResources();
            __cleanDrawCommands();
            __cleanTextures();
            __cleanAssets();
            __cleanPipelines();
            m_p_scc->SCCleanup();
            __cleanDSL();
            __cleanSemaphores();
            __freeBuffers();
            __cleanDevice();
        }


        /*
         * Add new assets to renderer asset list.
         * Also no descriptor sets are allocated since that
         * will be done when renderer is being fully initialised.
         */
        void __vk_Renderer::submitAssets (
            deng_Id *assets,
            deng_ui32_t asset_c
        ) {
            deng_ui32_t old_size = static_cast<deng_ui32_t>(m_assets.size());
            m_assets.resize(m_assets.size() + asset_c);

            // Create new assets with their descriptor sets
            for(deng_ui32_t i = old_size; i < static_cast<deng_ui32_t>(m_assets.size()); i++) { 
                RegType &reg_asset = m_reg.retrieve (
                    assets[i - old_size], 
                    DENG_SUPPORTED_REG_TYPE_ASSET
                );

                RegType reg_vk_asset;
                reg_vk_asset.vk_asset.base_id = reg_asset.asset.uuid;
                reg_vk_asset.vk_asset.tex_uuid = reg_asset.asset.tex_uuid;
                reg_vk_asset.vk_asset.uuid = uuid_Generate();
                reg_vk_asset.vk_asset.is_desc = false;
                reg_asset.asset.vk_id = reg_vk_asset.vk_asset.uuid;

                // Allocate uniform buffer memory for uniform color data
                m_p_rm->reserveAssetUniformData (
                    m_p_ic->getDev(), 
                    m_p_ic->getGpu(),
                    m_p_dc->getComPool(),
                    m_p_ic->getQFF().graphics_queue,
                    reg_vk_asset.vk_asset
                );

                m_reg.push (
                    reg_vk_asset.vk_asset.uuid, 
                    DENG_SUPPORTED_REG_TYPE_VK_ASSET,
                    reg_vk_asset
                );
                m_assets[i] = reg_vk_asset.vk_asset.uuid;
            }
        }


        /*
         * Add new textures to renderer texture list.
         */
        void __vk_Renderer::submitTextures (
            deng_Id *textures,
            deng_ui32_t tex_c
        ) {
            deng_ui32_t old_size = static_cast<deng_ui32_t>(m_textures.size());
            m_textures.resize(m_textures.size() + tex_c);

            for(deng_ui32_t i = old_size; i < static_cast<deng_ui32_t>(m_textures.size()); i++) {
                RegType reg_vk_tex;
                reg_vk_tex.vk_tex.base_id = textures[i - old_size];
                reg_vk_tex.vk_tex.uuid = uuid_Generate();
                reg_vk_tex.vk_tex.is_buffered = false;

                m_textures[i] = reg_vk_tex.vk_tex.uuid;

                m_reg.push (
                    reg_vk_tex.vk_tex.uuid,
                    DENG_SUPPORTED_REG_TYPE_VK_TEXTURE,
                    reg_vk_tex
                );

                RegType &reg_tex = m_reg.retrieve (
                    reg_vk_tex.vk_asset.base_id, 
                    DENG_SUPPORTED_REG_TYPE_TEXTURE
                );

                reg_tex.tex.vk_id = reg_vk_tex.vk_tex.uuid;
            }

            // Create vulkan image resources
            m_p_rm->mkTextures (
                m_p_ic->getDev(), 
                m_p_ic->getGpu(),
                m_p_dc->getComPool(),
                false,
                {old_size, static_cast<deng_ui32_t>(m_textures.size())},
                m_p_ic->getQFF().graphics_queue
            );
        }


        /*
         * Submit new draw calls and update uniform data
         */
        void __vk_Renderer::makeFrame() {
            // Call Vulkan fence waiter function
            vkWaitForFences (
                m_p_ic->getDev(), 
                1, 
                &m_p_dc->flight_fences[m_p_dc->current_frame], 
                VK_TRUE, 
                UINT64_MAX
            );

            // Call Vulkan next image acquire method
            deng_ui32_t image_index;
            VkResult result = vkAcquireNextImageKHR (
                m_p_ic->getDev(), 
                m_p_scc->getSC(), 
                UINT64_MAX, 
                m_p_dc->image_available_semaphore_set[m_p_dc->current_frame], 
                VK_NULL_HANDLE, 
                &image_index
            );
            
            if(result == VK_ERROR_OUT_OF_DATE_KHR) {
                VK_FRAME_ERR("image acquiring timed out");
                return;
            }
            
            else if(result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
                VK_FRAME_ERR("failed to acquire swap chain image");

            // Update uniform data buffer
            m_p_rm->updateUniformData (
                m_p_ic->getDev(), 
                m_p_dc->current_frame, 
                __max_frame_c,
                m_config.p_cam, 
                false,
                {0, 0},
                DENG_CAMERA_UNIFORM_NO_CAMERA_MODE_2D | 
                DENG_CAMERA_UNIFORM_PERSPECTIVE_CAMERA_MODE_3D
            );

            VkSemaphore wait_semaphores[] = 
            {m_p_dc->image_available_semaphore_set[m_p_dc->current_frame]};

            VkSemaphore signal_semaphores[] = 
            {m_p_dc->render_finished_semaphore_set[m_p_dc->current_frame]};

            VkSubmitInfo submitinfo{};
            submitinfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

            VkPipelineStageFlags wait_stages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
            submitinfo.waitSemaphoreCount = 1;
            submitinfo.pWaitSemaphores = wait_semaphores;
            submitinfo.pWaitDstStageMask = wait_stages;
            submitinfo.commandBufferCount = 1;
            submitinfo.pCommandBuffers = &m_p_dc->getComBufs()[image_index];
            submitinfo.signalSemaphoreCount = 1;
            submitinfo.pSignalSemaphores = signal_semaphores;

            vkResetFences (
                m_p_ic->getDev(), 
                1, 
                &m_p_dc->flight_fences[m_p_dc->current_frame]
            );

            if
            (
                vkQueueSubmit (
                    m_p_ic->getQFF().graphics_queue, 
                    1, 
                    &submitinfo, 
                    m_p_dc->flight_fences[m_p_dc->current_frame]
                ) != VK_SUCCESS
            ) VK_FRAME_ERR("failed to submit draw command"); 

            VkPresentInfoKHR present_info{};
            present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
            present_info.waitSemaphoreCount = 1;
            present_info.pWaitSemaphores = signal_semaphores;
            present_info.pImageIndices = &image_index;
            
            VkSwapchainKHR swapchains[] = {m_p_scc->getSC()};
            present_info.swapchainCount = 1;
            present_info.pSwapchains = swapchains;

            vkQueuePresentKHR (
                m_p_ic->getQFF().present_queue, 
                &present_info
            );

            m_p_dc->current_frame = (m_p_dc->current_frame + 1) % __max_frame_c;
        }


        /*
         * Setup the renderer, create descriptor sets, allocate buffers
         * and record command buffers
         */
        void __vk_Renderer::setup() {
            // Make and allocate memory for main buffer 
            m_p_rm->mkBuffers (
                m_p_ic->getDev(),
                m_p_ic->getGpu(),
                m_p_dc->getComPool(),
                m_p_ic->getQFF().graphics_queue
            );

            // Create descriptor sets for all currently available assets
            m_p_desc_c->mkDS (
                m_p_ic->getDev(), 
                m_p_rm->getBD(),
                m_p_rm->getDummyTexUUID(),
                { 0, (deng_ui32_t) m_assets.size() },
                m_p_ic->getGpuLimits().minUniformBufferOffsetAlignment
            );

            // Start recording command buffers
            m_p_dc->setMiscData (
                m_p_desc_c->getPipelines(),
                m_p_rm->getFB()
            );
            
            m_p_dc->allocateMainCmdBuffers (
                m_p_ic->getDev(), 
                m_p_ic->getQFF().graphics_queue, 
                m_p_scc->getRp(),
                m_p_scc->getExt(),
                m_config.background,
                m_p_rm->getBD()
            );
        }


        /*
         * Wait for any queue operation to finish
         * This method needs to be called whenever any 
         * command or data buffers need to be updated
         */
        void __vk_Renderer::idle() {
            vkDeviceWaitIdle(m_p_ic->getDev());
        }
    }

}
