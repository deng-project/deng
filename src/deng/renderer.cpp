/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __RENDERER_CPP
#include <deng/renderer.h>

// Shared data
dengui::MouseInputInfo ext_mii;

namespace deng {

    static deng_ui16_t text_box_c = 0;
    static deng_ui16_t texture_c = 0;
    static deng_ui16_t asset_c = 0; 


    /*******************************/
    /********** Renderer ***********/
    /*******************************/

    Renderer::Renderer (
        WindowWrap *p_win,
        void *p_cam,
        deng_CameraType camera_type
    ) { 
        m_p_camera = p_cam;
        m_main_camera_type = camera_type;
        m_p_ww = p_win; 
    }


    /* Submit assets for drawing */
    void Renderer::submitAssets (
        das_Asset *assets, 
        deng_i32_t asset_c
    ) {
        size_t l_index = m_assets.size(); 
        deng_i32_t r_index;
        m_assets.resize(l_index + asset_c);
        
        for(r_index = 0; r_index < asset_c; l_index++, r_index++) {
            m_assets[l_index] = assets[r_index];
        }
    } 


    /* 
     * Submit preconfigured das_Textures 
     */
    void Renderer::submitTextures (
        das_Texture *textures,
        deng_i32_t tex_c
    ) {
        size_t l_index = m_textures.size();
        deng_i32_t r_index;
        m_textures.resize(l_index + tex_c);

        for(r_index = 0; r_index < tex_c; l_index++, r_index++)
            m_textures[l_index].texture = textures[r_index];
    }


    /* 
     * Submit textures for mapping assets 
     */
    void Renderer::submitTextureFile (
        std::string tex_file, 
        std::string uuid
    ) {
        size_t cur_index = m_textures.size();
        m_textures.resize(cur_index + 1);
        // Load all texture image information
        das_LoadTexture(&m_textures[cur_index].texture, tex_file.c_str());
        m_textures[cur_index].texture.uuid = (char*) calloc (
            uuid.size() + 1,
            sizeof(char)
        );
        
        strncpy (
            m_textures[cur_index].texture.uuid,
            uuid.c_str(),
            uuid.size()
        );
    }


    /* 
     * Submit text instances to renderer and make them into das_Asset objects 
     */ 
    void Renderer::submitRendStr (
        dengUtils::BitmapStr *rend_strs, 
        size_t size
    ) {
        size_t asset_index = m_assets.size();
        size_t tex_index = m_textures.size();
        size_t l_index;

        m_assets.resize(asset_index + size);
        m_textures.resize(tex_index + size); 
        for(l_index = 0; l_index < size; asset_index++, tex_index++, l_index++) {
            text_box_c++;
            texture_c++;
            asset_c++;

            // Create new asset for text box
            m_assets[asset_index].asset_mode = DAS_ASSET_MODE_2D_TEXTURE_MAPPED;
            m_assets[asset_index].uuid = uuid_Generate();
            m_assets[asset_index].name = (char*) rend_strs[l_index].text;
            m_assets[asset_index].is_shown = true;
            m_assets[asset_index].vertices.vm2d = rend_strs[l_index].vert_pos.data();
            m_assets[asset_index].vertices.n = rend_strs[l_index].vert_pos.size();
            m_assets[asset_index].indices.indices = rend_strs[l_index].vert_indices.data();
            m_assets[asset_index].indices.n = rend_strs[l_index].vert_indices.size();
 
            // Create new texture for text box
            m_textures[tex_index].texture.description = (char*) rend_strs[l_index].text;
            m_textures[tex_index].texture.pixel_data.width = rend_strs[l_index].box_size.first;
            m_textures[tex_index].texture.pixel_data.height = rend_strs[l_index].box_size.second;
            m_textures[tex_index].texture.pixel_data.p_pixel_data = rend_strs[l_index].tex_data.data();
            m_textures[tex_index].texture.pixel_data.size = rend_strs[l_index].tex_data.size();
            m_textures[tex_index].texture.uuid = uuid_Generate();
            m_assets[asset_index].tex_uuid = m_textures[tex_index].texture.uuid;
        }
    }


    /* 
     * Set renderer hints
     */
    void Renderer::setHints (deng_RendererHintBits hints) {
        // Check if VSync should be enabled
        if(hints & DENG_RENDERER_HINT_ENABLE_VSYNC)
            m_enable_vsync = true;
        else m_enable_vsync = false;

        // Check if FPS counter should be enabled
        if(hints & DENG_RENDERER_HINT_SHOW_CMD_FPS_COUNTER)
            m_count_fps = true;
        else m_count_fps = false;

        // Check if Vulkan validation layers should be enabled
        if(hints & DENG_RENDERER_HINT_ENABLE_VALIDATION_LAYERS)
            m_enable_validation_layers = true;
        else m_enable_validation_layers = false;

        // Check for MSAA related flags
        if(hints & DENG_RENDERER_HINT_MSAA_MAX_HARDWARE_SUPPORTED)
            m_msaa_sample_count = m_p_ic->getMaxSampleCount();
        if
        (
            (hints & DENG_RENDERER_HINT_MSAA_64) && 
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_64_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_64_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_64) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_64_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();

        if
        (
            (hints & DENG_RENDERER_HINT_MSAA_32) &&
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_32_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_32_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_32) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_32_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();

        if
        (
            (hints & DENG_RENDERER_HINT_MSAA_16) &&
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_16_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_16_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_16) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_16_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();

        if
        (
            (hints & DENG_RENDERER_HINT_MSAA_8) &&
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_8_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_8_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_8) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_8_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();

        if 
        (
            (hints & DENG_RENDERER_HINT_MSAA_4) &&
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_4_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_4_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_4) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_4_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();

        if
        (
            (hints & DENG_RENDERER_HINT_MSAA_2) &&
            m_p_ic->getMaxSampleCount() >= VK_SAMPLE_COUNT_2_BIT
        ) m_msaa_sample_count = VK_SAMPLE_COUNT_2_BIT;
        else if
        (
            (hints & DENG_RENDERER_HINT_MSAA_2) &&
            m_p_ic->getMaxSampleCount() < VK_SAMPLE_COUNT_2_BIT
        ) m_msaa_sample_count = m_p_ic->getMaxSampleCount();
    }
} 
