/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __FPP_CAM_CPP
#include <deng/camera/fpp_cam.h>

extern deng::__SharedMouseData __ext_md;

namespace deng {

    /*********************************************/
    /****** First person perspective camera ******/
    /*********************************************/
    
    __FPPCameraEv::__FPPCameraEv (
        Window *p_win,
        const dengMath::vec2<deng_f64_t> &mouse_sens,
        const dengMath::vec3<deng_vec_t> &camera_mov_sens
    ) : __EventBase (
            {
                DENG_VCP_OVERFLOW_ACTION_TO_OPPOSITE_POSITION, 
                DENG_VCP_OVERFLOW_ACTION_BLOCK_POSITION
            },
            {{-BASE_MAX_VC_X / mouse_sens.first, BASE_MAX_VC_X / mouse_sens.first}, {-BASE_MAX_VC_Y / mouse_sens.second, BASE_MAX_VC_Y / mouse_sens.second}},
            { PI / 2, PI * 2 },
            p_win
    ) {
        m_p_win = p_win;
        m_move_speed.first = (deng_vec_t) (DENG_CAMERA_BASE_SPEED_X * camera_mov_sens.first);
        m_move_speed.second = (deng_vec_t) (DENG_CAMERA_BASE_SPEED_Y * camera_mov_sens.second);
        m_move_speed.third = (deng_vec_t) (DENG_CAMERA_BASE_SPEED_Z * camera_mov_sens.third);
        m_move_speed.fourth = 0.0f;
    }


    /* 
     * Find the current movement type and direction 
     */
    void __FPPCameraEv::__findMovements() {
        deng_bool_t mov_nw = __checkInputAction(DENG_CAMERA_ACTION_MOV_NW);
        deng_bool_t mov_w = __checkInputAction(DENG_CAMERA_ACTION_MOV_W);
        deng_bool_t mov_nv = __checkInputAction(DENG_CAMERA_ACTION_MOV_NV);
        deng_bool_t mov_v = __checkInputAction(DENG_CAMERA_ACTION_MOV_V);
        deng_bool_t mov_nu = __checkInputAction(DENG_CAMERA_ACTION_MOV_NU);
        deng_bool_t mov_u = __checkInputAction(DENG_CAMERA_ACTION_MOV_U);

        // We are assuming right handed coordinate system
        if(mov_nw && !mov_w) m_movements.third = DENG_MOVEMENT_FORWARD;
        else if(!mov_nw && mov_w) m_movements.third = DENG_MOVEMENT_BACKWARD;
        else m_movements.third = DENG_MOVEMENT_NONE;

        if(mov_nu && !mov_u) m_movements.first = DENG_MOVEMENT_LEFTWARD;
        else if(!mov_nu && mov_u) m_movements.first = DENG_MOVEMENT_RIGHTWARD;
        else m_movements.first = DENG_MOVEMENT_NONE;

        if(!mov_nv && mov_v) m_movements.second = DENG_MOVEMENT_UPWARD;
        else if(mov_nv && !mov_v) m_movements.second = DENG_MOVEMENT_DOWNWARD;
        else m_movements.second = DENG_MOVEMENT_NONE;
    }

    
    /* 
     * Check if input FPP camera mouse input mode has changed 
     * This method is not thread safe and can cause race conditions, make sure that __ext_md.mut is locked!
     */
    void __FPPCameraEv::__checkForInputModeChange(dengMath::CameraMatrix *p_vm) {
        __EventBase::__updateMouseEvData();

        // Check if input mode should be changed ([ESC] key)
        if (
            m_input_mode_timer.isTimePassed(DENG_KEY_PRESS_INTERVAL) &&
            __checkInputAction(DENG_CAMERA_ACTION_CHANGE_MM)
        ) {
            m_p_win->toggleVCMode();
			m_input_mode_timer.setNewTimePoint();
        }

        __ext_md.mut.lock();
        __ext_md.is_mouse_input = !m_p_win->isVCP();
        __ext_md.mut.unlock();

        // Check if virtual mouse cursor mode is enabled and 
        // if true then update camera rotation and key events
        if(m_p_win->isVCP()) {
            __findMovements();
            dengMath::vec2<deng_f64_t> rot = __EventBase::__getMouseRotation();
            p_vm->setCameraRotation (
                (deng_vec_t) rot.first, 
                (deng_vec_t) rot.second
            );
            p_vm->camTransform(false);
        }

        else {
            m_movements.first = DENG_MOVEMENT_NONE;
            m_movements.second = DENG_MOVEMENT_NONE;
            m_movements.third = DENG_MOVEMENT_NONE;
        }
    }


    /*
     * Check for input mode changes and move camera if needed
     */
    void __FPPCameraEv::updateEv (
        __FPPCamera *p_cam,
        deng_bool_t ignore_pitch
    ) {
        __checkForInputModeChange(p_cam->getCamMatPtr());
        if (m_mov_timer.isTimePassed(DENG_MOVEMENT_INTERVAL)) {
            switch (m_movements.first)
            {
            case DENG_MOVEMENT_LEFTWARD:
                p_cam->moveU(-m_move_speed.first, ignore_pitch);
                break;

            case DENG_MOVEMENT_RIGHTWARD:
                p_cam->moveU(m_move_speed.first, ignore_pitch);
                break;

            case DENG_MOVEMENT_NONE: break;

            default:
                break;
            }

            switch (m_movements.second)
            {
            case DENG_MOVEMENT_UPWARD:
                p_cam->moveV(-m_move_speed.second, ignore_pitch);
                break;

            case DENG_MOVEMENT_DOWNWARD:
                p_cam->moveV(m_move_speed.second, ignore_pitch);
                break;

            case DENG_MOVEMENT_NONE: break;

            default:
                break;
            }

            switch (m_movements.third)
            {
            case DENG_MOVEMENT_FORWARD:
                p_cam->moveW(-m_move_speed.first, ignore_pitch);
                break;

            case DENG_MOVEMENT_BACKWARD:
                p_cam->moveW(m_move_speed.first, ignore_pitch);
                break;

            default:
                break;
            }
            m_mov_timer.setNewTimePoint();
        }
    }


    /*
     * Get the pointer to the window instance
     */
    Window *__FPPCameraEv::getWinPtr() {
        return m_p_win;
    }

    
    /*
     * Set the window pointer
     */
    void __FPPCameraEv::setWinPtr(Window *p_win) {
        m_p_win = p_win;
    }


    /*
     * Find the correct movement speed
     * Parameters for this method are boolean flags about the axis being opposite or not
     */
    dengMath::vec4<deng_vec_t> __FPPCameraEv::getMoveSpeed (
        deng_bool_t op_x,
        deng_bool_t op_y,
        deng_bool_t op_z
    ) { 
        dengMath::vec4<deng_vec_t> move_speed;

        if(op_x)
            move_speed.first = -m_move_speed.first;
        else move_speed.first = m_move_speed.first;

        if(op_y)
            move_speed.second = m_move_speed.second;
        else move_speed.second = -m_move_speed.second;

        if(op_z)
            move_speed.third = -m_move_speed.third;
        else move_speed.third = m_move_speed.third;

        return move_speed; 
    } 


    /************************************/
    /************************************/
    /************ __FPPCamera ***********/
    /************************************/
    /************************************/

    __FPPCamera::__FPPCamera (
        const dengMath::vec3<deng_vec_t> &camera_mov_sens, 
		const dengMath::vec2<deng_f64_t> &mouse_sens, 
		deng_vec_t fov, 
		deng_vec_t near_plane, 
		deng_vec_t far_plane, 
        deng_bool_t ignore_pitch_mov,
		Window *p_win
	) : __FPPCameraEv (
            p_win,
            mouse_sens, 
            camera_mov_sens
        ),
        __CameraBase (
            DENG_CAMERA_TYPE_FPP,
            fov,
            {near_plane, far_plane},
            (deng_vec_t) __FPPCameraEv::getWinPtr()->getSize().first / (deng_vec_t) __FPPCameraEv::getWinPtr()->getSize().second
        ) {
        __FPPCameraEv::setWinPtr(p_win);
    }


    /* 
     * __FPPCamera wrapper method for event update 
     */
    void __FPPCamera::update() {
        updateEv (
            this, 
            m_is_pitch_ignore
        );
    }

    
    /*
     * Set first person camera control bindings
     */
    void __FPPCamera::setBindings(const Camera3DBindings &bindings) {
        m_bindings = bindings;
    }

    
    /*
     * Check if camera movement system should ignore pitch rotation, when translating
     * movements into camera coordinate system.
     */
    deng_bool_t __FPPCamera::isPitchIgnore() {
        return m_is_pitch_ignore;
    }


    /*
     * Get the pointer to camera matrix instance
     */
    dengMath::CameraMatrix *__FPPCamera::getCamMatPtr() {
        return &m_cam_mat;
    }
}
