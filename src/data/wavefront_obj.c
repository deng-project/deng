/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __WAVEFRONT_OBJ_C
#include <data/wavefront_obj.h>

/*
 * Read all filedata from stream to heap allocated memory
 */
void __das_ReadToBuffer(char *file_name) {
    FILE *file;
    file = fopen(file_name, "rb");

    if(!file) FILE_ERR(file_name);
    
    fseek(file, 0, SEEK_END);
    long file_c = ftell(file);
    fseek(file, 0, SEEK_SET);

    __buffer = (char*) calloc (
        file_c + 1,
        sizeof(char)
    );

    size_t res = fread (
        __buffer,
        file_c,
        sizeof(char),
        file
    );

    if(!res) FILE_ERR(file_name);
}


/*
 * Free the allocated buffer used in data reading
 */
void __das_FreeBuffer() {
    free(__buffer);
}


/*
 * Remove all comments declared with hash character '#'
 */
void __das_Uncomment() {
    char *ptr = __buffer;
    char *max = __buffer + strlen(__buffer);
    while(ptr < max && (ptr = strchr(ptr, (int) '#'))) {
        // Loop until newline and replace all characters in comments
        // with whitespaces ' '
        while(ptr < max && *ptr != 0x0a) {
            *ptr = 0x20;
            ptr++;
        }

        ptr++;
    }
}


/*
 * Check if memory reallocations need to be done
 */
void __das_ReallocCheck (
    void **p_data, 
    size_t *p_cap, 
    size_t n,
    size_t size,
    char *err_msg
) {
    if(n >= (*p_cap) / size) {
        (*p_cap) = (*p_cap) << 1;
        void *tmp = realloc (
            (*p_data),
            (*p_cap)
        );

        if(!tmp) MEM_ERR(err_msg);
        
        (*p_data) = tmp;
    }
}


/*
 * Start reading from beg until trailing characters are found
 * and set end to the end of reading point
 */
deng_vec_t __das_ReadFloatValue (
    char *beg, 
    char *max, 
    char **p_end
) {
    char *ptr = beg;
    *p_end = beg + 1;
    if((*p_end) >= max) 
        return FLT_MAX;

    char data_buf[32] = {0};
    // Skip whitespaces and tabs
    while(ptr < max && !((*ptr <= '9' && *ptr >= '0') || *ptr == '.' || *ptr == '-')) 
        ptr++;
    
    // Find the end of x axis coordinate
    *p_end = ptr;
    while(*p_end < max && ((**p_end <= '9' && **p_end >= '0') || **p_end == '.' || **p_end == '-'))
        (*p_end)++;

    strncpy(data_buf, ptr, (*p_end) - ptr);

    // Try to convert string into floating point integer
    return (deng_vec_t) atof(data_buf);
}


/*
 * Start reading from beg until training characters are found
 * and set end to the end of reading point. Read integer will be 
 * unsigned
 */
deng_ui32_t __das_ReadIntValue (
    char *beg,
    char *max,
    char **p_end
) {
    char *ptr;
    deng_ui32_t out = 0;
    ptr = beg;

    if(ptr + 1 < max) {
        // Skip until numbers
        while(ptr < max && (*ptr < '0' || *ptr > '9'))
            ptr++;

        // Find the end of numerical chars
        *p_end = ptr;
        while((*p_end) < max && ((**p_end) <= '9' && (**p_end) >= '0'))
            (*p_end)++;

        if((*p_end) - ptr) {
            char buf[64] = {0};
            strncpy (
                buf,
                ptr,
                (*p_end) - ptr
            );

            out = atoi(buf);
        }
    }

    return out;
}


/*
 * Parse one face block and return found indices
 * p_end is the pointer to the end of the block
 */
__das_IndexBlock __das_ParseIndBlock(char *beg, char *nl, char **p_end) {
    __das_IndexBlock is = {0};

    // Skip whitespaces from the beginning
    while(beg < nl) {
        if(*beg <= '9' && *beg >= '0')
            break;
        beg++;
    }

    // Find the end of the index block
    deng_bool_t found_end = false;
    *p_end = beg;
    while((*p_end) < nl) {
        if(**p_end == 0x20 || **p_end == 0x09) {
            found_end = true;
            break;
        }

        (*p_end)++;
    }

    if(!found_end)
        *p_end = nl;

    char *ptr = beg;
    char *end = ptr;

    // Find separating slashes
    char *sl1 = strchr(ptr, '/');
    char *sl2 = sl1 ? strchr(sl1 + 1, '/') : NULL;

    // Find model vertex index
    is.pos = __das_ReadIntValue(ptr, nl, &end);
    if(!sl1 || sl1 + 1 >= *p_end)
        return is;

    // Find texture index
    if(sl2 - sl1 != 1) {
        ptr = sl1;
        is.tex = __das_ReadIntValue(ptr, nl, &end);
    }

    // Return if no second slash was found
    if(!sl2) return is;

    // Find vertex normal index
    ptr = sl2;
    is.norm = __das_ReadIntValue(ptr, nl, &end);
    return is;
}




/*
 * Parse all data about vertices to their appropriate structures
 */
void __das_ParseVertices(das_VertDynamic *p_vert) {
    // Initialise asset vertex type capacities and allocate memory accordingly
    size_t vd_cap = BUFFER_CAP(das_ObjPosData);
    size_t td_cap = BUFFER_CAP(das_ObjTextureData);
    size_t nd_cap = BUFFER_CAP(das_ObjNormalData);

    p_vert->v3d.pos = (das_ObjPosData*) malloc(vd_cap);
    p_vert->v3d.tex = (das_ObjTextureData*) malloc(td_cap);
    p_vert->v3d.norm = (das_ObjNormalData*) malloc(nd_cap);

    p_vert->v3d.pn = 0;
    p_vert->v3d.tn = 0;
    p_vert->v3d.nn = 0;

    char *ptr = __buffer;
    char *end = __buffer;
    char *nl = __buffer;
    char *max = __buffer + strlen(__buffer);
    size_t li = 0;
    size_t pdi = 0, tdi = 0, ndi = 0;


    // Start searching for vertices marked as 'v', 'vt' or 'vn'
    while(ptr && ptr < max && (ptr = strchr(ptr, (int) 'v'))) {
        // Verify vertex line correctness
        nl = strchr(ptr, 0x0a);
        nl = !nl ? max : nl;
        li++;
        char *cptr = ptr + 2 > nl ? nl : ptr + 2;

        // Skip the whitespaces for the cptr
        while(cptr < nl && (*cptr == 0x20 || *cptr == 0x09))
            cptr++;

        // Check if all conditions for vertex data declaration are satisfied
        while(cptr < nl) {
            deng_bool_t is_num = *cptr <= '9' && *cptr >= '0';

            // Basically this means that the sign cannot be the last element. Also this check verifies 
            // if that the previous character is either space or a tab and the next character some number.
            deng_bool_t is_sign = cptr != nl - 1 && (*cptr == '-' || *cptr == '+') && (*(cptr - 1) == 0x20 || 
                *(cptr - 1) == 0x09) && (*(cptr + 1) <= '9' && *(cptr + 1) >= '0');

            // Period cannot be the last element before newline, also previous and next characters 
            // have to be ASCII numbers
            deng_bool_t is_period = cptr != nl - 1 && *cptr == '.' && *(cptr - 1) <= '9' && *(cptr + 1) >= '0';

            // If not a single check was successful then the vertex declaration syntax is invalid
            if(!is_num && !is_sign && !is_period && *cptr != 0x20 && *cptr != 0x09) {
                deng_ui32_t line = cm_FindLineCount(__buffer, cptr - __buffer);
                char msg_buf[128] = { 0 };
                sprintf(msg_buf, "Invalid symbol '%c' on vertex declaration", *cptr);
                __DAS_WAVEFRONT_SYNTAX_ERROR(line, msg_buf);
                break;
            }

            cptr++;
        }

        // Check if the vertex block is a position vertex
        if(ptr + 1 < max && (*(ptr + 1) == 0x20 || *(ptr + 1) == 0x09)) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck((void**) &p_vert->v3d.pos, &vd_cap, pdi + 1, 
                sizeof(das_ObjPosData), "vertex data buffer");

            p_vert->v3d.pos[p_vert->v3d.pn].vert_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            p_vert->v3d.pos[p_vert->v3d.pn].vert_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            p_vert->v3d.pos[p_vert->v3d.pn].vert_z = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            pdi++;
        }

        else if(ptr + 2 < max && *(ptr + 1) == 't' && *(ptr + 2) == 0x20) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck((void**) &p_vert->v3d.tex, &td_cap, tdi + 1, 
                sizeof(das_ObjTextureData), "texture vertex data buffer");

            p_vert->v3d.tex[p_vert->v3d.tn].tex_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            p_vert->v3d.tex[p_vert->v3d.tn].tex_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            tdi++;
        }

        else if(ptr + 2 < max && *(ptr + 1) == 'n' && *(ptr + 2) == 0x20) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck((void**) &p_vert->v3d.norm, &nd_cap, ndi + 1, 
                sizeof(das_ObjNormalData), "vertex normals data buffer");

            p_vert->v3d.norm[p_vert->v3d.nn].nor_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            p_vert->v3d.norm[p_vert->v3d.nn].nor_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            p_vert->v3d.norm[p_vert->v3d.nn].nor_z = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            ndi++;
        }

        else ptr++;
    }

    p_vert->v3d.pn = pdi;
    p_vert->v3d.tn = tdi;
    p_vert->v3d.nn = ndi;
}


/*
 * Parse all data about indices to their appropriate structures
 */
void __das_ParseFaces (
    das_IndicesDynamic *p_ind,
    deng_bool_t read_tex_ind,
    deng_bool_t read_norm_ind
) {
    // In wavefront obj format faces are stored like this:
    // f v1/vt1/vn1 v2/vt2/vt2 v3/vt3/vn3
    // Or like this:
    // f v1//vn1 v2//vn2 v3//vn3
    // Or like this:
    // f v1/vt1 v2/vt2 v3/vt3
    char *ptr = __buffer;
    char *nl = __buffer;
    char *max = __buffer + strlen(__buffer);
    char *end;

    // Allocate memory for indices
    size_t pos_ind_cap = BUFFER_CAP(deng_ui32_t);
    size_t tex_ind_cap = BUFFER_CAP(deng_ui32_t);
    size_t nor_ind_cap = BUFFER_CAP(deng_ui32_t);

    p_ind->n = 0;
    p_ind->pos = (deng_ui32_t*) calloc(pos_ind_cap, sizeof(deng_ui32_t)); 
    p_ind->tex = (deng_ui32_t*) calloc(tex_ind_cap, sizeof(deng_ui32_t)); 
    p_ind->norm = (deng_ui32_t*) calloc(nor_ind_cap, sizeof(deng_ui32_t)); 
    __das_IndexBlock ib = { 0 };

    // For each face parse it
    while(ptr && ptr < max && (ptr = strchr(ptr, (int) 'f'))) {
        if(ptr + 1 >= max || *(ptr + 1) != 0x20) {
            ptr++;
            continue;
        }
        
        nl = strchr(ptr, 0x0a);
        nl = nl ? nl : max;
        
        // Parse every single face block
        while(ptr < nl) {
            // Parse the current index 
            ib = __das_ParseIndBlock(ptr, nl, &end);

            // Check if reallocation is needed for any indices elements
            __das_ReallocCheck((void**) &p_ind->pos, &pos_ind_cap, p_ind->n + 1, 
                sizeof(deng_ui32_t), "position indices buffer");

            __das_ReallocCheck((void**) &p_ind->tex, &tex_ind_cap, p_ind->n + 1, 
                sizeof(deng_ui32_t), "texture indices buffer");

            __das_ReallocCheck((void**) &p_ind->norm, &nor_ind_cap, p_ind->n + 1, 
                sizeof(deng_ui32_t), "vertex normal indices buffer");


            // Verify that normals and texture indices are not read if not needed
            ib.pos = 0;
            ib.tex = 0;
            ib.norm = 0;

            p_ind->n++;
            p_ind->pos[p_ind->n - 1] = ib.pos;
            p_ind->tex[p_ind->n - 1] = ib.tex;
            p_ind->norm[p_ind->n - 1] = ib.norm;
            ptr = end;

        }
    }
}


/*
 * Parse all data in Wavefront OBJ file and write
 * all information about vertices and indices to p_asset
 */
void das_ParseWavefrontOBJ (
    das_Asset *p_asset,
    das_AssetMode am,
    char *file_name
) {
    __das_ReadToBuffer(file_name);
    __das_Uncomment();
    p_asset->asset_mode = am;

    // Parse all vertices in OBJ file
    __das_ParseVertices(&p_asset->vertices);

    // Parse faces and recieve indices
    switch(am) {
    case __DAS_ASSET_MODE_3D_TEXTURE_MAPPED_UNOR:
        __das_ParseFaces(&p_asset->indices, true, false);
        break;
    
    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        __das_ParseFaces(&p_asset->indices, true, true);
        break;

    case __DAS_ASSET_MODE_3D_UNMAPPED_UNOR:
        __das_ParseFaces(&p_asset->indices, false, false);
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED:
        __das_ParseFaces(&p_asset->indices, false, true);
        break;

    default:
        break;
    }

    
    // Check if vertex normals need to be generated
    if(!p_asset->vertices.v3d.nn) 
        das_MkAssetNormals(p_asset);

    // Write all vertices into log file 
    cm_OpenLogger("vert.log");
    char buf[256] = {0};
    for(size_t i = 0; i < p_asset->vertices.v3d.pn; i++) {
        memset(buf, 0, 256);
        sprintf(buf, "v %f %f %f", p_asset->vertices.v3d.pos[i].vert_x, 
            p_asset->vertices.v3d.pos[i].vert_y, p_asset->vertices.v3d.pos[i].vert_z);
        cm_LogWrite(buf);
    }
    cm_CloseLogger();
    __das_FreeBuffer();
}
