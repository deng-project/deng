/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __UI_CALLBACKS_CPP
#include <dengui/ui_callbacks.h>

namespace dengui {
    static dengUtils::StringRasterizer *__p_sr;
    static dengMath::vec2<deng_ui32_t> __deng_win_area;
    Window *__help_win = NULL; 


    /* Setup all global variables needed for callbacks */
    void setupCallbacks (
        dengUtils::StringRasterizer *p_sr,
        dengMath::vec2<deng_ui32_t> deng_win_area
    ) {
        __p_sr = p_sr;
        __deng_win_area = deng_win_area;
    }

    void cleanCallbacks (
        Window *p_win,
        Events *p_ev
    ) {
        if(__help_win)
            delete __help_win;
    }


    /* Testing callback for adding new window elements */
    void helloCallback (
        WindowElement *p_elem, 
        Events *p_ev
    ) {
        printf("Hello world!\n");
    }

    /* Test callback for drop down menus */
    void helloCallback (
        DDMElement *p_elem, 
        Events *p_ev
    ) {
        printf("Hello world!\n");
    }


    /* Trigger help window generation */
    void ddmHelpCallback (
        DDMElement *p_elem, 
        Events *p_ev
    ) {
        if(__help_win)
            respawnWindow(__help_win, p_ev);
        else {
            WindowInfo wi;
            wi.border = BORDER_LIGHT;
            wi.fl_b = DENGUI_WINDOW_FLAG_NO_COLLAPSE;
            wi.id = "help_form";
            wi.label = "Help";
            wi.pc = DENGUI_DEFAULT_PRIMARY_COLOR;
            wi.sc = DENGUI_DEFAULT_SECONDARY_COLOR;
            wi.tc = DENGUI_DEFAULT_TERTIARY_COLOR;
            wi.wt = WINDOW_TYPE_FLOATING;
            wi.pos = {-0.25f, -0.25f};
            wi.size = {0.5f, 0.5f};
            
            beginWindow (
                &__help_win,
                &wi,
                __deng_win_area,
                __p_sr,
                p_ev,
                true
            );
        }
    }

    
    /*************************************************/
    /*************************************************/
    /******** Base window handling callbacks *********/
    /*************************************************/
    /*************************************************/
    void minTriangleCallback (
        WindowElement *p_cur_elem,
        Events *p_ev
    ) {
        size_t l_index;
        std::vector<das_Asset> *p_assets;
        std::vector<WindowElement> *p_elems;
        p_elems = p_ev->getWinElems(p_cur_elem->parent_id);
        if(!p_elems)
            return;
        
        dengMath::vec2<deng_ui32_t> asset_bounds;

        p_ev->frame_upd.lockAssets();
        p_ev->toggleWindow(p_cur_elem->parent_id);
        p_assets = p_ev->getAssets();
        asset_bounds = p_ev->getWindowAssetBounds(p_cur_elem->parent_id);    

        // Unhide maximise triangle element

        for(l_index = 0; l_index < p_elems->size(); l_index++) {
            if(p_elems->at(l_index).child_id == DENGUI_MAXIMISE_TRIANGLE_ID) {
                p_assets->at(l_index + asset_bounds.first).is_shown = true;
                break;
            }
        }
        
        p_ev->frame_upd.unlockAssets();

        p_ev->frame_upd.lockFrame();
        p_ev->frame_upd.updateCmdBuffers();
        p_ev->frame_upd.unlockFrame();
    }


    void maxTriangleCallback (
        WindowElement *p_cur_elem,
        Events *p_ev
    ) {
        size_t l_index;
        std::vector<das_Asset> *p_assets;
        std::vector<WindowElement> *p_elems;
        p_elems = p_ev->getWinElems(p_cur_elem->parent_id);
        if(!p_elems) return;
        
        dengMath::vec2<deng_ui32_t> asset_bounds;

        p_ev->frame_upd.lockAssets();
        p_ev->toggleWindow(p_cur_elem->parent_id);
        p_assets = p_ev->getAssets();
        asset_bounds = p_ev->getWindowAssetBounds(p_cur_elem->parent_id);    

        // Unhide maximise triangle element
        for(l_index = 0; l_index < p_elems->size(); l_index++) {
            if(p_elems->at(l_index).child_id == DENGUI_MAXIMISE_TRIANGLE_ID) {
                p_assets->at(l_index + asset_bounds.first).is_shown = false;
                break;
            }
        }
        
        p_ev->frame_upd.unlockAssets();

        p_ev->frame_upd.lockFrame();
        p_ev->frame_upd.updateCmdBuffers();
        p_ev->frame_upd.unlockFrame();
    }


    void closeBtnCallback (
        WindowElement *p_cur_elem,
        Events *p_ev
    ) {
        /* Remove all window elements */
        p_ev->frame_upd.lockFrame();
        p_ev->windowAssetRmSync(p_cur_elem->parent_id);
        p_ev->checkWindowElements();
        p_ev->frame_upd.reallocBuffer();
        p_ev->frame_upd.updateTexDS(false, NULL);
        p_ev->frame_upd.updateCmdBuffers();
        p_ev->frame_upd.unlockFrame();
    }
}
