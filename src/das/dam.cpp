/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


/*
 * This code was originally written is C but had to be put into C++ 
 * for the purpose of viewing asset file previews
 */


#define __DAM_C
#include <das/dam.h>


/*
 * Read information about the asset
 * Information is following:
 *  - UUID of the asset
 *  - Date and time of the creation
 *  - Type of vertices
 *  - Total count of unique vertices
 *  - Total count of drawn vertices
 */
void __dam_ListAsset(char *file_name) {
    das_INFO_HDR inf_hdr = {};
    das_VERT_HDR vert_hdr = {};
    das_INDX_HDR indx_hdr = {};
    __das_ReadAssetFile(file_name);
    __das_ReadINFOHDR (
        &inf_hdr, 
        file_name
    );

    char *date; char *time;
    cm_FormatTimeFromEpoch (
        DATE_FORMAT_YMD_SP_HYPHEN,
        TIME_FORMAT_24_HOUR_SP_COLON,
        inf_hdr.time_st,
        &date,
        &time
    );

    // Create padded strings
    char pad_name[9] = {0};
    char pad_uuid[37] = {0};


    __das_ReadVERTHDR (
        &vert_hdr,
        file_name
    );

    strncpy(pad_name, vert_hdr.hdr_name, 8);
    strncpy(pad_uuid, inf_hdr.uuid, 36);

    // Increment reading offset for file buffer
    switch(inf_hdr.asset_type)
    {
    case DAS_ASSET_MODE_3D_UNMAPPED:
        __das_IncrementOffset(vert_hdr.vert_c * sizeof(VERT_UNMAPPED_UNOR));
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        __das_IncrementOffset(vert_hdr.vert_c * sizeof(VERT_UNMAPPED_NOR));
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        __das_IncrementOffset(vert_hdr.vert_c * sizeof(VERT_MAPPED_UNOR));
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        __das_IncrementOffset(vert_hdr.vert_c * sizeof(VERT_MAPPED_NOR));
        break;

    default:
        break;
    }

    // Skip all custom header data
    __das_SkipCustomHeaders();
    __das_ReadINDXHDR (
        &indx_hdr,
        file_name
    );

    cm_FormatTimeFromEpoch (
        DATE_FORMAT_YMD_SP_HYPHEN,
        TIME_FORMAT_24_HOUR_SP_COLON,
        inf_hdr.time_st,
        &date,
        &time
    );

    printf("UUID: %s\n", pad_uuid);
    printf (
        "Date and time of creation: %s %s(UTC)\n", 
        date,
        time
    );

    switch(inf_hdr.asset_type)
    {
    case DAS_ASSET_MODE_3D_UNMAPPED:
        printf("Vertex type: vertices only\n");
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        printf("Vertex type: normalized vertices\n");
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        printf("Vertex type: textured vertices\n");
        break;
    
    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        printf("Vertex type: normalized textured vertices\n");
        break;

    default:
        break;
    }


    printf("Unique vertices: %d\n", vert_hdr.vert_c);
    printf("Indexed vertices: %d\n", indx_hdr.ind_c);
    __das_ReadCleanup();
}


/*
 * Create a valid asset instance with sorted indices
 */
void __dam_AssetAssemblyCaller(dam_AssetAsmInfo info) {
    char *dst_ext = cm_ExtractFileExtName(info.out_file);
    char *model_ext = cm_ExtractFileExtName(info.model_file);
    char ext_file[128] = {0};
    
    // Check if file extension needs to be added
    if(!dst_ext || (dst_ext && strcmp(dst_ext, "das"))) {
        sprintf (
            ext_file,
            "%s.das",
            info.out_file
        );
    }

    else {
        sprintf (
            ext_file,
            "%s",
            info.out_file   
        );
    }


    das_Asset asset = {0};
    asset.asset_mode = info.am;
    // Check for supported 3D model formats and parse them
    if(model_ext && !strcmp(model_ext, "obj")) {
        das_ParseWavefrontOBJ (
            &asset, 
            asset.asset_mode,
            info.model_file
        );
    }

    else __DAM_INVALID_MODEL_FORMAT(model_ext);


    // Assemble the file itself
    // Currently no custom headers will be used
    das_Assemble (
        &asset,
        ext_file,
        NULL,
        0
    );


    // Cleanup
    switch(asset.asset_mode) 
    {
    case DAS_ASSET_MODE_3D_UNMAPPED:
        free(asset.vertices.vuu);
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        free(asset.vertices.vun);
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        free(asset.vertices.vmu);
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        free(asset.vertices.vmn);
        break;

    default:
        break;
    }

    free(asset.indices.indices);
}


/*
 * Find information about asset preview 
 */
dam_AssetPreviewInfo __dam_FindPreviewInfo(int argc, char *argv[]) {
    dam_AssetPreviewInfo info = {0};
    info.width = __DAM_DEFAULT_PREVIEW_WIDTH;
    info.height = __DAM_DEFAULT_PREVIEW_HEIGHT;
    info.file_name = argv[2];

    for(int i = 3; i < argc; i++) {
        if(!strcmp(argv[i], "-g") || !strcmp(argv[i], "--geometry")) {
            if(i == argc - 1)
                __DAM_EXPECTED_PARAMETER(argv[i], "geometry specifier");
            else {
                char *x = strchr(argv[i], (int) 'x');
                if(!x || x == argv[i] + strlen(argv[i])) 
                    __DAM_INVALID_PARAMETER(argv[i], "[WIDTH]x[HEIGHT]");

                char str_width[32] = {0};
                char str_height[32] = {0};
                strncpy(str_width, argv[i], x - argv[i]);
                strncpy(str_height, x + 1, strlen(argv[i]) - (x - argv[i] + 1));

                info.width = atoi(str_width);
                info.height = atoi(str_height);
            }
        }
    }

    // Read the asset data from file into das_Asset instance
    info.asset.force_unmap = true;
    info.asset.color = __DAM_DEFAULT_ASSET_COLOR;
    das_ReadAsset (
        &info.asset,
        DAS_ASSET_MODE_DONT_CARE,
        info.file_name
    );

    return info;
}


/*
 * Create new DENG renderer instance and review
 * given DENG asset file
 */
//void __dam_PreviewAsset(dam_AssetPreviewInfo info) {
    //// Create new WindowWrap instance
    //deng::WindowWrap win(info.width, info.height, __DAM_PREVIEW_TITLE);

    //// Create new editor camera instance
    //// There are currently temporary values used but the configuration should be 
    //// read from the config files instead. 
    //deng::EditorCamera ed_cam (
        //0.2f,
        //{0.0f, 0.0f, 0.0f},
        //{0.7f, 0.7f},
        //dengMath::Conversion::degToRad(65.0f),
        //DENG_DEFAULT_NEAR_PLANE,
        //DENG_DEFAULT_FAR_PLANE,
        //&win
    //);

    //deng::Renderer rend (
        //&win,
        //&ed_cam, 
        //DENG_CAMERA_EDITOR
    //);

    //rend.setHints (
        //DENG_RENDERER_HINT_API_VULKAN |
        //DENG_RENDERER_HINT_ENABLE_VALIDATION_LAYERS |
        //DENG_RENDERER_HINT_MSAA_4 |
        //DENG_RENDERER_HINT_MIPMAP_ENABLE
    //);

    //// Load a sample texture
    //das_Texture tex;
    //das_LoadTexture(&tex, "textures/brick.tga");

    //// Submit the preview asset into renderer
    //info.asset.is_shown = true;
    //info.asset.tex_uuid = tex.uuid;

    //// There needs to be a way to disable texture mapping in assets!
    //rend.submitTextures(&tex, 1);
    //rend.submitAssets(&info.asset, 1);

    //rend.initRenderer (
        //DENG_RENDERER_USAGE_GAME_MODE, 
        //{0.0f, 0.0f, 0.0f, 1.0f}
    //);

    //rend.run();
//}


/*
 * Find information about asset creation
 * And throw possible error point if not enough flags are specified
 */
dam_AssetAsmInfo __dam_FindAssetAsmInfo(int argc, char *argv[]) {
    dam_AssetAsmInfo asm_info = {0};
    asm_info.out_file = (char*) "asset.das";
    asm_info.am = DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED;

    for(int i = 2; i < argc; i++) {
        if(!strcmp(argv[i], "-m") || !strcmp(argv[i], "--model")) {
            if(argc <= i + 1)
                __DAM_EXPECTED_PARAMETER(argv[i], "model file name");

            i++;
            asm_info.model_file = argv[i];
        }

        else if(!strcmp(argv[i], "-o")) {
            if(argc <= i + 1)
                __DAM_EXPECTED_PARAMETER(argv[i], "output file name");

            i++;
            asm_info.out_file = argv[i];
        }

        else if(!strcmp(argv[i], "-v") || !strcmp(argv[i], "--vert")) {
            if(argc <= i + 1)
                __DAM_EXPECTED_PARAMETER(argv[i], "vertices storage mode");

            i++;
            // Parse vertex storage parameter
            if(!strcmp(argv[i], "v"))
                asm_info.am = DAS_ASSET_MODE_3D_UNMAPPED;
            else if(!strcmp(argv[i], "vn"))
                asm_info.am = DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED;
            else if(!strcmp(argv[i], "vm"))
                asm_info.am = DAS_ASSET_MODE_3D_TEXTURE_MAPPED;
            else if(!strcmp(argv[i], "vmn"))
                asm_info.am = DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED;
        }
    }

    return asm_info;
}


int main(int argc, char *argv[]) {
    /**** Base flag actions *****/
    // No additional arguments given
    if(argc == 1) {
        printf("DENG asset manager %s\n", DAM_VERSION);
        TO_HELP;
    }
    // View the current version of DAM
    else if(argc == 2 && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")))
        printf("DENG asset manager %s\n", DAM_VERSION);

    // View help text
    else if(argc == 2 && (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")))
        printf("%s", __help_text);

    // New asset creation
    else if(argc > 2 && !strcmp(argv[1], "-n")) {
        printf("Converting model into DENG asset...\n");
        dam_AssetAsmInfo asm_info = __dam_FindAssetAsmInfo(argc, argv);
        __dam_AssetAssemblyCaller(asm_info);
        printf("Done!\n");
    }

    // Preview asset
    else if(argc > 2 && (!strcmp(argv[1], "-p") || !strcmp(argv[1], "--preview"))) {
        dam_AssetPreviewInfo preview_info = __dam_FindPreviewInfo(argc, argv);
        printf("Setting up preview for asset %s\n", preview_info.file_name);
        //__dam_PreviewAsset(preview_info);

        // Perform asset data cleanup
        free(preview_info.asset.indices.indices);
        switch(preview_info.asset.asset_mode)
        {
        case DAS_ASSET_MODE_3D_UNMAPPED:
            free(preview_info.asset.vertices.vuu);
            break;

        case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
            free(preview_info.asset.vertices.vun);
            break;

        case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
            free(preview_info.asset.vertices.vmu);
            break;

        case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
            free(preview_info.asset.vertices.vmn);
            break;

        default:
            break;
        }
    }

    // View asset information
    else if(argc >= 2)
        __dam_ListAsset(argv[1]);


    return EXIT_SUCCESS;
}
