/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __WAVEFRONT_OBJ_C
#include <das/wavefront_obj.h>

/*
 * Read all filedata from stream to heap allocated memory
 */
void __das_ReadToBuffer(char *file_name) {
    FILE *file;
    file = fopen(file_name, "rb");

    if(!file) FILE_ERR(file_name);
    
    fseek(file, 0, SEEK_END);
    long file_c = ftell(file);
    fseek(file, 0, SEEK_SET);

    __buffer = (char*) calloc (
        file_c + 1,
        sizeof(char)
    );

    fread (
        __buffer,
        file_c,
        sizeof(char),
        file
    );
}


/*
 * Free the allocated buffer used in data reading
 */
void __das_FreeBuffer() {
    free(__buffer);
}


/*
 * Remove all comments declared with hash character '#'
 */
void __das_Uncomment() {
    char *ptr = __buffer;
    char *max = __buffer + strlen(__buffer);
    while(ptr < max && (ptr = strchr(ptr, (int) '#'))) {
        // Loop until newline and replace all characters in comments
        // with whitespaces ' '
        while(ptr < max && *ptr != 0x0a) {
            *ptr = 0x20;
            ptr++;
        }

        ptr++;
    }
}


/*
 * Check if memory reallocations need to be done
 */
void __das_ReallocCheck (
    void **p_data, 
    size_t *p_cap, 
    size_t n,
    size_t size,
    char *err_msg
) {
    if(n >= (*p_cap) / size) {
        (*p_cap) = (*p_cap) << 1;
        void *tmp = realloc (
            (*p_data),
            (*p_cap)
        );

        if(!tmp) MEM_ERR(err_msg);

        (*p_data) = tmp;
    }
}


/*
 * Start reading from beg until trailing characters are found
 * and set end to the end of reading point
 */
deng_vec_t __das_ReadFloatValue (
    char *beg, 
    char *max, 
    char **p_end
) {
    char *ptr = beg;
    *p_end = beg + 1;
    if((*p_end) >= max) 
        return FLT_MAX;

    char data_buf[32] = {0};
    // Skip whitespaces and tabs
    while(ptr < max && !((*ptr <= '9' && *ptr >= '0') || *ptr == '.' || *ptr == '-')) 
        ptr++;
    
    // Find the end of x axis coordinate
    *p_end = ptr;
    while(*p_end < max && ((**p_end <= '9' && **p_end >= '0') || **p_end == '.' || **p_end == '-'))
        (*p_end)++;

    strncpy(data_buf, ptr, (*p_end) - ptr);

    // Try to convert string into floating point integer
    return (deng_vec_t) atof(data_buf);
}


/*
 * Start reading from beg until training characters are found
 * and set end to the end of reading point. Read integer will be 
 * unsigned
 */
deng_ui32_t __das_ReadIntValue (
    char *beg,
    char *max,
    char **p_end
) {
    char *ptr;
    deng_ui32_t out = 0;
    ptr = beg;

    if(ptr + 1 < max) {
        // Skip until numbers
        while(ptr < max && (*ptr < '0' || *ptr > '9'))
            ptr++;

        // Find the end of numerical chars
        *p_end = ptr;
        while((*p_end) < max && ((**p_end) <= '9' && (**p_end) >= '0'))
            (*p_end)++;

        if((*p_end) - ptr) {
            char buf[64] = {0};
            strncpy (
                buf,
                ptr,
                (*p_end) - ptr
            );

            out = atoi(buf);
        }
    }

    return out;
}


/*
 * Parse one face block and return found indices
 * p_end is the pointer to the end of the block
 */
IndexSet __das_ParseIndBlock (
    char *beg,
    char *nl,
    char **p_end
) {
    IndexSet is = {0};

    // Skip whitespaces from beginning
    while(beg < nl) {
        if(*beg <= '9' && *beg >= '0')
            break;

        beg++;
    }

    // Skip whitspaces and tabs
    deng_bool_t found_end = false;
    *p_end = beg;
    while((*p_end) < nl) {
        if(**p_end == 0x20 || **p_end == 0x09) {
            found_end = true;
            break;
        }

        (*p_end)++;
    }

    if(!found_end)
        *p_end = nl;

    char *ptr = beg;
    char *end = ptr;

    // Find separating slashes
    char *sl1 = strchr(ptr, '/');
    char *sl2 = sl1 ? strchr(sl1 + 1, '/') : NULL;
    
    // Find model vertex index
    is.vert = __das_ReadIntValue(ptr, nl, &end);
    if(!sl1 || sl1 + 1 >= *p_end)
        return is;

    // Find texture index
    ptr = sl1;
    is.tex = __das_ReadIntValue(ptr, nl, &end);

    if(!sl2 || sl2 >= *p_end)
        return is;

    // Find vertex normal index
    ptr = sl2;
    is.norm = __das_ReadIntValue(ptr, nl, &end);
    return is;
}




/*
 * Parse all data about vertices to their appropriate structures
 */
void __das_ParseVertices (
    das_ObjVertData **pp_vd,
    size_t *p_vd_c,
    das_ObjTextureData **pp_td,
    size_t *p_td_c,
    das_ObjNormalData **pp_nd,
    size_t *p_nd_c
) {
    size_t vd_cap = BUFFER_CAP(das_ObjVertData);
    size_t td_cap = BUFFER_CAP(das_ObjTextureData);
    size_t nd_cap = BUFFER_CAP(das_ObjNormalData);

    (*pp_vd) = (das_ObjVertData*) malloc(vd_cap);
    (*pp_td) = (das_ObjTextureData*) malloc(td_cap);
    (*pp_nd) = (das_ObjNormalData*) malloc(nd_cap);

    (*p_vd_c) = 0;
    (*p_td_c) = 0;
    (*p_nd_c) = 0;

    char *ptr = __buffer;
    char *end = __buffer;
    char *nl = __buffer;
    char *max = __buffer + strlen(__buffer);
    size_t li = 0;
    size_t vdi = 0, tdi = 0, ndi = 0;


    // Start searching for vertices marked as 'v', 'vt' or 'vn'
    while(ptr && ptr < max && (ptr = strchr(ptr, (int) 'v'))) {
        // Verify vertex line correctness
        nl = !strchr(ptr, 0x0a) ? max : strchr(ptr, 0x0a);
        li++;
        char *vptr = ptr;
        deng_bool_t is_vert = true;

        // Check if all conditions for vertex data declaration are satisfied
        while(vptr < nl) {
            if (
                (*vptr > '9' || *vptr <= '0') && 
                *vptr != '-' &&
                *vptr != '.' &&
                *vptr != 'v' && 
                *vptr != 't' && 
                *vptr != 'n' && 
                *vptr != 0x20 && 
                *vptr != 0x09
            ) {
                is_vert = false;
                break;
            }

            vptr++;
        }

        if(is_vert) {
            ptr++;
            continue;
        }

        // Check for position vertex
        if(ptr + 1 < max && *(ptr + 1) == 0x20) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck (
                (void**) pp_vd, 
                &vd_cap, 
                vdi + 1, 
                sizeof(das_ObjVertData),
                "vertex data buffer"
            );

            (*pp_vd)[vdi].vert_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            (*pp_vd)[vdi].vert_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            (*pp_vd)[vdi].vert_z = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            vdi++;
        }

        else if(ptr + 2 < max && *(ptr + 1) == 't' && *(ptr + 2) == 0x20) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck (
                (void**) pp_td, 
                &td_cap, 
                tdi + 1, 
                sizeof(das_ObjTextureData),
                "texture vertex data buffer"
            );

            (*pp_td)[tdi].tex_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            (*pp_td)[tdi].tex_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            tdi++;
        }

        else if(ptr + 2 < max && *(ptr + 1) == 'n' && *(ptr + 2) == 0x20) {
            // Skip whitespaces and tabs
            ptr++;
            // Check if memory needs to be reallocated
            __das_ReallocCheck (
                (void**) pp_nd, 
                &nd_cap, 
                ndi + 1, 
                sizeof(das_ObjNormalData),
                "vertex normals data buffer"
            );

            (*pp_nd)[ndi].nor_x = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            (*pp_nd)[ndi].nor_y = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            (*pp_nd)[ndi].nor_z = __das_ReadFloatValue(ptr, max, &end);
            ptr = end;
            ndi++;
        }

        else ptr++;
    }

    (*p_vd_c) = vdi;
    (*p_td_c) = tdi;
    (*p_nd_c) = ndi;

    // LOG vertices into a file
    char buf[128];
    cm_OpenLogger("vert_log.txt");
    for(size_t i = 0; i < (*p_nd_c); i++) {
        memset(buf, 0, 128);
        sprintf (
            buf,
            "vn %f %f %f",
            (*pp_nd)[i].nor_x,
            (*pp_nd)[i].nor_y,
            (*pp_nd)[i].nor_z
        );
        cm_LogWrite(buf);
    }

    cm_CloseLogger();
}


/*
 * Parse all data about indices to their appropriate structures
 */
void __das_ParseFaces (
    IndexSet **p_ind,
    size_t *p_ind_c,
    deng_bool_t read_tex_ind,
    deng_bool_t read_norm_ind
) {
    // f v1/vt1/vn1 v2/vt2/vt2 v3/vt3/vn3
    char *ptr = __buffer;
    char *nl = __buffer;
    char *max = __buffer + strlen(__buffer);
    char *end;

    IndexSet is;
    size_t ind_cap = BUFFER_CAP(IndexSet);
    (*p_ind_c) = 0;
    (*p_ind) = (IndexSet*) malloc(ind_cap); 

    while(ptr && ptr < max && (ptr = strchr(ptr, (int) 'f'))) {
        if(ptr + 1 >= max || *(ptr + 1) != 0x20) {
            ptr++;
            continue;
        }

        nl = strchr(ptr, 0x0a) ? strchr(ptr, 0x0a) : max;
        
        while(ptr < nl) {
            is = __das_ParseIndBlock(ptr, nl, &end);

            // Check if reallocation is needed
            __das_ReallocCheck (
                (void**) p_ind, 
                &ind_cap, 
                (*p_ind_c) + 1, 
                sizeof(IndexSet),
                "faces indices buffer"
            );


            // Verify that normals and texture indices are not read if not needed
            if(!read_tex_ind)
                is.tex = 0;
            if(!read_norm_ind)
                is.norm = 0;

            (*p_ind_c)++;
            (*p_ind)[(*p_ind_c) - 1] = is;
            ptr = end;

        }
    }
}


/****************************/
/****** Vertex merging ******/
/****************************/


/*
 * Merge multiple different vertices into one vertex
 */
void __das_MergeVertices (
    das_ObjVertData *vd,
    size_t vd_c,
    das_ObjTextureData *td,
    size_t td_c,
    das_ObjNormalData *nd,
    size_t nd_c,
    IndexSet *is,
    size_t ind_c,
    deng_ui32_t **p_out_is,
    das_VertDynamic *p_out_vdy,
    das_AssetMode asset_mode
) {
    // Allocate memory for output indices
    deng_ui32_t max_ind = 0;
    (*p_out_is) = (deng_ui32_t*) calloc (
        ind_c,
        sizeof(deng_ui32_t)
    );

    // Allocate memory for dynamic vertices
    switch(asset_mode)
    {
    case DAS_ASSET_MODE_3D_UNMAPPED:
        // Allocate memory and copy model vertices over as well as indices 
        // Nothing else to do here
        p_out_vdy->vuu = (VERT_UNMAPPED_UNOR*) calloc (
            vd_c,
            sizeof(VERT_UNMAPPED_UNOR)
        );

        for(size_t i = 0; i < vd_c; i++)
            p_out_vdy->vuu[i]= vd[i];

        for(size_t i = 0; i < ind_c; i++)
            (*p_out_is)[i] = is[i].vert;

        p_out_vdy->n = vd_c;
        return;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        p_out_vdy->vun = (VERT_UNMAPPED_NOR*) calloc (
            ind_c,
            sizeof(VERT_UNMAPPED_NOR)
        );
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        p_out_vdy->vmu = (VERT_MAPPED_UNOR*) calloc (
            ind_c,
            sizeof(VERT_MAPPED_UNOR)
        );
        break;

    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        p_out_vdy->vmn = (VERT_MAPPED_NOR*) calloc (
            ind_c,
            sizeof(VERT_MAPPED_NOR)
        );
        break;

    default:
        RUN_ERR("__das_MergeVertices: invalid asset mode");
        break;
    }


    // Make hashmap twice as big than indices to avoid collisions
    Hashmap hm;
    newHashmap(&hm, 2 * ind_c);

    deng_ui32_t *p_ind;
    VERT_UNMAPPED_NOR vun = {0};
    VERT_MAPPED_UNOR vmu = {0};
    VERT_MAPPED_NOR vmn = {0};

    for(size_t i = 0; i < ind_c; i++) {
        switch(asset_mode) 
        {
        case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
            vun.vert_data = vd[is[i].vert];
            vun.norm_data = nd[is[i].norm];

            // Check if index exists in new_ind array
            if ( 
                (p_ind = (deng_ui32_t*) findValue ( 
                    &hm, 
                    &vun, 
                    sizeof(VERT_UNMAPPED_NOR)
                ))
            ) (*p_out_is)[i] = *p_ind;

            // If it doesn't then push it to hashmap
            else {
                (*p_out_is)[i] = max_ind;
                p_out_vdy->n++;
                p_out_vdy->vun[max_ind] = vun;
                pushToHashmap (
                    &hm,
                    &vun,
                    sizeof(VERT_UNMAPPED_NOR),
                    (*p_out_is) + i
                );
                max_ind++;
            }
            break;

        case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
            vmu.vert_data = vd[is[i].vert];
            vmu.tex_data = td[is[i].tex];

            // Check if index exists in new_ind array
            if ( 
                (p_ind = (deng_ui32_t*) findValue ( 
                    &hm, 
                    &vmu, 
                    sizeof(VERT_MAPPED_UNOR)
                ))
            ) (*p_out_is)[i] = *p_ind;

            // If it doesn't then push it to hashmap
            else {
                (*p_out_is)[i] = max_ind;
                p_out_vdy->n++;
                p_out_vdy->vmu[max_ind] = vmu;
                pushToHashmap (
                    &hm,
                    &vmu,
                    sizeof(VERT_MAPPED_UNOR),
                    (*p_out_is) + i
                );
                max_ind++;
            }
            break;

        case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
            vmn.vert_data = vd[is[i].vert];
            vmn.norm_data = nd[is[i].norm];
            vmn.tex_data = td[is[i].tex];

            // Check if index exists in new_ind array
            if ( 
                (p_ind = (deng_ui32_t*) findValue ( 
                    &hm, 
                    &vmn, 
                    sizeof(VERT_MAPPED_NOR)
                ))
            ) (*p_out_is)[i] = *p_ind;

            // If it doesn't then push it to hashmap
            else {
                (*p_out_is)[i] = max_ind;
                p_out_vdy->n++;
                p_out_vdy->vmn[max_ind] = vmn;
                pushToHashmap (
                    &hm,
                    &p_out_vdy->vmn[max_ind],
                    sizeof(VERT_MAPPED_NOR),
                    (*p_out_is) + i
                );
                max_ind++;
            }
            break;

        default:
            break;
        }
    }

    free(hm.map_data);
}


/*
 * Create a valid asset instance with sorted indices
 */
void __das_AssembleAsset (
    das_Asset *p_asset,
    IndexSet *inds,
    size_t ind_c,
    das_ObjVertData *vd,
    size_t vd_c,
    das_ObjTextureData *td,
    size_t td_c,
    das_ObjNormalData *nd,
    size_t nd_c
) {
    // Reduce indices size by one
    for(size_t i = 0; i < ind_c; i++) {
        inds[i].vert--;
        inds[i].norm--;
        inds[i].tex--;
    }

    p_asset->indices.n = ind_c;
    __das_MergeVertices (
        vd,
        vd_c, 
        td, 
        td_c, 
        nd, 
        nd_c, 
        inds, 
        ind_c, 
        &p_asset->indices.indices,
        &p_asset->vertices,
        p_asset->asset_mode
    );


    // Free all memory resources used
    if(inds) free(inds);
    if(vd) free(vd);
    if(td) free(td);
    if(nd) free(nd);
}


/*
 * Parse all data in Wavefront OBJ file and write
 * all information about vertices and indices to p_asset
 */
void das_ParseWavefrontOBJ (
    das_Asset *p_asset,
    das_AssetMode am,
    char *file_name
) {
    __das_ReadToBuffer(file_name);
    __das_Uncomment();
    p_asset->asset_mode = am;
    das_ObjVertData *vd = NULL;   
    size_t vd_c = 0;
    das_ObjTextureData *td = NULL;
    size_t td_c = 0;
    das_ObjNormalData *nd = NULL;
    size_t nd_c = 0;

    // Parse all vertices in OBJ file
    __das_ParseVertices (
        &vd,
        &vd_c,
        &td,
        &td_c,
        &nd,
        &nd_c
    );

    IndexSet *ind = NULL;
    size_t ind_c = 0;

    // Parse faces and recieve indices
    switch(am)
    {
    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED:
        __das_ParseFaces (
            &ind,
            &ind_c, 
            true,
            false
        );
        break;
    
    case DAS_ASSET_MODE_3D_TEXTURE_MAPPED_NORMALISED:
        __das_ParseFaces (
            &ind,
            &ind_c,
            true,
            true
        );
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED:
        __das_ParseFaces (
            &ind,
            &ind_c,
            false,
            false
        );
        break;

    case DAS_ASSET_MODE_3D_UNMAPPED_NORMALISED:
        __das_ParseFaces (
            &ind,
            &ind_c,
            false,
            true
        );
        break;

    default:
        break;
    }


    // Right now attempt to log all of the parsed data to certain file
    /*char buf[128]; */
    /*cm_OpenLogger("out.log");*/
    /*// Log all vertices*/
    /*cm_LogWrite("vert");*/
    /*for(size_t i = 0; i < vd_c; i++) {*/
        /*memset(buf, 0, 128);*/
        /*sprintf (*/
            /*buf,*/
            /*"%f, %f, %f",*/
            /*vd[i].vert_x,*/
            /*vd[i].vert_y,*/
            /*vd[i].vert_z*/
        /*);*/

        /*cm_LogWrite(buf);*/
    /*}*/

    /*cm_LogWrite("texture");*/
    /*for(size_t i = 0; i < td_c; i++) {*/
        /*memset(buf, 0, 128);*/
        /*sprintf (*/
            /*buf,*/
            /*"%f, %f",*/
            /*td[i].tex_x,*/
            /*td[i].tex_y*/
        /*);*/

        /*cm_LogWrite(buf);*/
    /*}*/

    /*cm_LogWrite("normals");*/
    /*for(size_t i = 0; i < nd_c; i++) {*/
        /*memset(buf, 0, 128);*/
        /*sprintf (*/
            /*buf,*/
            /*"%f, %f, %f",*/
            /*nd[i].nor_x,*/
            /*nd[i].nor_y,*/
            /*nd[i].nor_z*/
        /*);*/

        /*cm_LogWrite(buf);*/
    /*}*/

    __das_AssembleAsset (
        p_asset,
        ind,
        ind_c,
        vd,
        vd_c,
        td,
        td_c,
        nd,
        nd_c
    );
    __das_FreeBuffer();
}
